"""
Document Parser Service
–£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–∞—Ä—Å–µ—Ä –¥–ª—è –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ (PDF, DOCX, TXT)
services/doc_parser.py

- PDF —á–µ—Ä–µ–∑ pdfplumber
- DOCX —á–µ—Ä–µ–∑ python-docx  
- TXT –Ω–∞–ø—Ä—è–º—É—é
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ —Ñ–∞–π–ª–∞
"""

import logging
import pdfplumber
from pathlib import Path
from docx import Document as DocxDocument
from typing import Optional, Dict, Any, List
from dataclasses import dataclass
import zipfile
import tempfile
import os

logger = logging.getLogger(__name__)

@dataclass
class ParseResult:
    """Result of document parsing"""
    content: str
    file_path: str
    file_type: str
    success: bool
    error: Optional[str] = None
    metadata: Dict[str, Any] = None

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}

class UnifiedDocumentParser:
    """
    Unified document parser that handles multiple file types and formats
    Supports PDF, DOCX, TXT files with integration capabilities
    """
    
    def __init__(self):
        self.doc_parser = DocParser()
        # Mock other parsers for compatibility
        self.smeta_parser = None
        self.xml_parser = None
        self.supported_extensions = ['pdf', 'docx', 'txt', 'md', 'xlsx', 'csv', 'xml']
        logger.info("üìÑ UnifiedDocumentParser –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    def parse_document(self, file_path: str) -> Dict[str, Any]:
        """
        Parse a document and return structured results
        
        Args:
            file_path: Path to the file to parse
            
        Returns:
            Dict with success status, results, and metadata
        """
        try:
            file_path = Path(file_path)
            
            if not file_path.exists():
                return {
                    "success": False,
                    "error": f"File not found: {file_path}",
                    "results": [],
                    "source_type": "file",
                    "files_processed": 0
                }
            
            # Handle ZIP files
            if file_path.suffix.lower() == '.zip':
                return self._parse_zip_file(file_path)
            
            # Parse single file
            content = self.doc_parser.parse(str(file_path))
            
            if content:
                result = ParseResult(
                    content=content,
                    file_path=str(file_path),
                    file_type=file_path.suffix.lower(),
                    success=True,
                    metadata={"size": file_path.stat().st_size}
                )
                
                return {
                    "success": True,
                    "results": [result],
                    "source_type": "file",
                    "files_processed": 1,
                    "error": None
                }
            else:
                return {
                    "success": False,
                    "error": f"Failed to parse content from {file_path}",
                    "results": [],
                    "source_type": "file",
                    "files_processed": 0
                }
                
        except Exception as e:
            logger.error(f"‚ùå Error parsing document {file_path}: {e}")
            return {
                "success": False,
                "error": str(e),
                "results": [],
                "source_type": "file",
                "files_processed": 0
            }
    
    def _parse_zip_file(self, zip_path: Path) -> Dict[str, Any]:
        """Parse files from a ZIP archive"""
        try:
            results = []
            files_processed = 0
            
            with zipfile.ZipFile(zip_path, 'r') as zip_file:
                with tempfile.TemporaryDirectory() as temp_dir:
                    for file_info in zip_file.infolist():
                        if file_info.is_dir():
                            continue
                            
                        # Extract file
                        extracted_path = zip_file.extract(file_info, temp_dir)
                        file_path = Path(extracted_path)
                        
                        # Parse extracted file
                        content = self.doc_parser.parse(str(file_path))
                        
                        if content:
                            result = ParseResult(
                                content=content,
                                file_path=file_info.filename,
                                file_type=file_path.suffix.lower(),
                                success=True,
                                metadata={"size": file_info.file_size, "from_zip": True}
                            )
                            results.append(result)
                            files_processed += 1
            
            return {
                "success": True,
                "results": results,
                "source_type": "zip_archive",
                "files_processed": files_processed,
                "error": None
            }
            
        except Exception as e:
            logger.error(f"‚ùå Error parsing ZIP file {zip_path}: {e}")
            return {
                "success": False,
                "error": str(e),
                "results": [],
                "source_type": "zip_archive",
                "files_processed": 0
            }
    
    def get_file_info(self, file_path: str) -> Dict[str, Any]:
        """Get metadata about a file"""
        try:
            path = Path(file_path)
            if not path.exists():
                return {"error": "File not found"}
                
            return {
                "name": path.name,
                "size": path.stat().st_size,
                "extension": path.suffix.lower(),
                "supported": path.suffix.lower().lstrip('.') in self.supported_extensions
            }
        except Exception as e:
            return {"error": str(e)}


class DocParser:
    """
    –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–∞—Ä—Å–µ—Ä –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç PDF, DOCX, TXT —Ñ–∞–π–ª—ã
    """
    
    def __init__(self):
        self.czech_encodings = ['utf-8', 'cp1250', 'iso-8859-2']
        logger.info("üìÑ DocParser –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    def parse(self, file_path: str) -> str:
        """
        –ü–∞—Ä—Å–∏–Ω–≥ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –≤ —Ç–µ–∫—Å—Ç
        
        Args:
            file_path: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É
            
        Returns:
            –ò–∑–≤–ª–µ—á–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –∏–ª–∏ –ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ
        """
        try:
            file_path = Path(file_path)
            
            if not file_path.exists():
                logger.error(f"‚ùå –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {file_path}")
                return ""
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Ñ–∞–π–ª–∞ –ø–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—é
            extension = file_path.suffix.lower()
            
            if extension == '.pdf':
                return self._parse_pdf(file_path)
            elif extension == '.docx':
                return self._parse_docx(file_path)
            elif extension in ['.txt', '.md']:
                return self._parse_text(file_path)
            else:
                logger.warning(f"‚ö†Ô∏è –ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø —Ñ–∞–π–ª–∞: {extension}")
                # –ü—ã—Ç–∞–µ–º—Å—è —á–∏—Ç–∞—Ç—å –∫–∞–∫ —Ç–µ–∫—Å—Ç
                return self._parse_text(file_path)
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ {file_path}: {e}")
            return ""
    
    def _parse_pdf(self, file_path: Path) -> str:
        """–ü–∞—Ä—Å–∏–Ω–≥ PDF —Ñ–∞–π–ª–∞"""
        try:
            with pdfplumber.open(file_path) as pdf:
                text_parts = []
                for page in pdf.pages:
                    page_text = page.extract_text()
                    if page_text:
                        text_parts.append(page_text)
                
                result = '\n'.join(text_parts)
                logger.info(f"‚úÖ PDF –æ–±—Ä–∞–±–æ—Ç–∞–Ω: {len(result)} —Å–∏–º–≤–æ–ª–æ–≤")
                return result
                
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ PDF {file_path}: {e}")
            return ""
    
    def _parse_docx(self, file_path: Path) -> str:
        """–ü–∞—Ä—Å–∏–Ω–≥ DOCX —Ñ–∞–π–ª–∞"""
        try:
            doc = DocxDocument(file_path)
            text_parts = []
            
            for paragraph in doc.paragraphs:
                if paragraph.text.strip():
                    text_parts.append(paragraph.text)
            
            result = '\n'.join(text_parts)
            logger.info(f"‚úÖ DOCX –æ–±—Ä–∞–±–æ—Ç–∞–Ω: {len(result)} —Å–∏–º–≤–æ–ª–æ–≤")
            return result
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ DOCX {file_path}: {e}")
            return ""
    
    def _parse_text(self, file_path: Path) -> str:
        """–ü–∞—Ä—Å–∏–Ω–≥ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –∫–æ–¥–∏—Ä–æ–≤–æ–∫"""
        # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ –∫–æ–¥–∏—Ä–æ–≤–∫–∏ –¥–ª—è —á–µ—à—Å–∫–∏—Ö —Ç–µ–∫—Å—Ç–æ–≤
        for encoding in self.czech_encodings:
            try:
                with open(file_path, 'r', encoding=encoding) as f:
                    result = f.read()
                    logger.info(f"‚úÖ –¢–µ–∫—Å—Ç –æ–±—Ä–∞–±–æ—Ç–∞–Ω ({encoding}): {len(result)} —Å–∏–º–≤–æ–ª–æ–≤")
                    return result
            except UnicodeDecodeError:
                continue
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞ {file_path} —Å –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π {encoding}: {e}")
                continue
        
        logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Ñ–∞–π–ª {file_path} –Ω–∏ —Å –æ–¥–Ω–æ–π –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π")
        return ""
    
    def get_supported_extensions(self) -> list:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π"""
        return ['.pdf', '.docx', '.txt', '.md']


# Global instance for singleton pattern
_unified_parser = None

def get_unified_document_parser() -> UnifiedDocumentParser:
    """Get singleton instance of UnifiedDocumentParser"""
    global _unified_parser
    if _unified_parser is None:
        _unified_parser = UnifiedDocumentParser()
    return _unified_parser

def parse_document(file_path: str) -> Dict[str, Any]:
    """
    Convenience function to parse a document
    
    Args:
        file_path: Path to the file to parse
        
    Returns:
        Dict with success status, results, and metadata
    """
    parser = get_unified_document_parser()
    return parser.parse_document(file_path)

# MinerU integration placeholder
def extract_with_mineru_if_available(file_path: str) -> Optional[str]:
    """
    Placeholder for MinerU integration
    Returns None if MinerU is not available or fails
    """
    try:
        # MinerU integration would go here
        # For now, return None to fallback to standard parsing
        return None
    except Exception:
        return None
