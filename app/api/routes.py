"""
API Routes for Czech Building Audit System
CORE endpoints - upload, status, knowledge base
–ò–°–ü–†–ê–í–õ–ï–ù–û: Streaming upload, –≤–∞–ª–∏–¥–∞—Ü–∏—è, –±–µ–∑ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
"""
from pathlib import Path
from typing import Dict, Any, List, Optional
from datetime import datetime
import json
import logging
import uuid
import aiofiles

from fastapi import APIRouter, UploadFile, File, HTTPException, BackgroundTasks, Form, Query
from fastapi.responses import FileResponse, JSONResponse

from app.core.config import settings
from app.services.workflow_a import WorkflowA
from app.services.workflow_b import WorkflowB
from app.models.project import (
    ProjectStatus,
    ProjectResponse,
    ProjectStatusResponse,
    WorkflowType,
)

logger = logging.getLogger(__name__)
router = APIRouter()

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
MAX_FILE_SIZE = 50 * 1024 * 1024  # 50 MB –Ω–∞ —Ñ–∞–π–ª
ALLOWED_EXTENSIONS = {
    'vykaz': {'.xml', '.xlsx', '.xls', '.pdf'},
    'vykresy': {'.pdf', '.dwg', '.dxf', '.png', '.jpg', '.jpeg'},
    'dokumentace': {'.pdf', '.doc', '.docx', '.xlsx', '.xls'},
}

# In-memory project store (–≤ production –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ –ë–î)
project_store: Dict[str, Dict[str, Any]] = {}


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

async def _validate_file(
    file: UploadFile, 
    file_type: str,
    max_size: int = MAX_FILE_SIZE
) -> None:
    """
    –í–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞–≥—Ä—É–∂–∞–µ–º–æ–≥–æ —Ñ–∞–π–ª–∞
    
    Args:
        file: –ó–∞–≥—Ä—É–∂–∞–µ–º—ã–π —Ñ–∞–π–ª
        file_type: –¢–∏–ø —Ñ–∞–π–ª–∞ ('vykaz', 'vykresy', 'dokumentace')
        max_size: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –≤ –±–∞–π—Ç–∞—Ö
    
    Raises:
        ValueError: –ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ –ø—Ä–æ—à–µ–ª –≤–∞–ª–∏–¥–∞—Ü–∏—é
    """
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è
    file_ext = Path(file.filename).suffix.lower()
    allowed = ALLOWED_EXTENSIONS.get(file_type, set())
    
    if file_ext not in allowed:
        raise ValueError(
            f"Nepodporovan√Ω form√°t pro {file_type}: {file_ext}. "
            f"Povolen√©: {', '.join(allowed)}"
        )
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ (—á–µ—Ä–µ–∑ seek - –±–µ–∑ –∑–∞–≥—Ä—É–∑–∫–∏ –≤ –ø–∞–º—è—Ç—å)
    file.file.seek(0, 2)  # –ö–æ–Ω–µ—Ü —Ñ–∞–π–ª–∞
    size = file.file.tell()
    file.file.seek(0)  # –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –Ω–∞—á–∞–ª–æ
    
    if size > max_size:
        raise ValueError(
            f"Soubor {file.filename} je p≈ô√≠li≈° velk√Ω: {size / 1024 / 1024:.1f} MB. "
            f"Maximum: {max_size / 1024 / 1024:.0f} MB"
        )
    
    logger.info(f"‚úÖ Validace OK: {file.filename} ({size / 1024:.1f} KB)")


async def _save_file_streaming(file: UploadFile, save_path: Path) -> int:
    """
    –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª –∏—Å–ø–æ–ª—å–∑—É—è streaming (–ø–∞–º—è—Ç—å-—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ)
    
    Args:
        file: –ó–∞–≥—Ä—É–∂–∞–µ–º—ã–π —Ñ–∞–π–ª
        save_path: –ü—É—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
    
    Returns:
        –†–∞–∑–º–µ—Ä —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –≤ –±–∞–π—Ç–∞—Ö
    """
    CHUNK_SIZE = 1024 * 1024  # 1 MB chunks
    total_size = 0
    
    try:
        async with aiofiles.open(save_path, 'wb') as f:
            while True:
                chunk = await file.read(CHUNK_SIZE)
                if not chunk:
                    break
                await f.write(chunk)
                total_size += len(chunk)
        
        logger.info(f"üíæ Ulo≈æeno: {save_path.name} ({total_size / 1024:.1f} KB)")
        return total_size
        
    except Exception as e:
        # –£–¥–∞–ª–∏—Ç—å —á–∞—Å—Ç–∏—á–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
        if save_path.exists():
            save_path.unlink()
        raise


async def _process_project_background(
    project_id: str,
    workflow: str,
    vykaz_path: Optional[Path],
    vykresy_paths: List[Path],
    project_name: str
):
    """
    –§–æ–Ω–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞
    
    Args:
        project_id: ID –ø—Ä–æ–µ–∫—Ç–∞
        workflow: –¢–∏–ø workflow ("A" –∏–ª–∏ "B")
        vykaz_path: –ü—É—Ç—å –∫ –≤—ã–∫–∞–∑—É (–¥–ª—è Workflow A)
        vykresy_paths: –ü—É—Ç–∏ –∫ —á–µ—Ä—Ç–µ–∂–∞–º
        project_name: –ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞
    """
    import gc
    
    try:
        logger.info(f"üöÄ Zaƒç√≠n√°m zpracov√°n√≠ projektu {project_id} (Workflow {workflow})")
        
        # –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å
        if project_id in project_store:
            project_store[project_id]["status"] = ProjectStatus.PROCESSING
        
        # –í—ã–±—Ä–∞—Ç—å –∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å workflow
        if workflow == "A":
            workflow_service = WorkflowA()
            result = await workflow_service.execute(
                project_id=project_id,
                vykaz_path=vykaz_path,
                vykresy_paths=vykresy_paths,
                project_name=project_name
            )
        else:  # workflow == "B"
            workflow_service = WorkflowB()
            result = await workflow_service.execute(
                project_id=project_id,
                vykresy_paths=vykresy_paths,
                project_name=project_name
            )
        
        # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        results_dir = settings.DATA_DIR / "results" / project_id
        results_dir.mkdir(parents=True, exist_ok=True)
        
        results_path = results_dir / f"audit_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        async with aiofiles.open(results_path, 'w', encoding='utf-8') as f:
            await f.write(json.dumps(result, ensure_ascii=False, indent=2))
        
        # –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å
        if project_id in project_store:
            project_store[project_id].update({
                "status": ProjectStatus.COMPLETED,
                "results_path": str(results_path),
                "total_positions": result.get("total_positions", 0),
                "green_count": result.get("green_count", 0),
                "amber_count": result.get("amber_count", 0),
                "red_count": result.get("red_count", 0),
                "completed_at": datetime.now().isoformat()
            })
        
        logger.info(f"‚úÖ Projekt {project_id} dokonƒçen √∫spƒõ≈°nƒõ")
        
    except Exception as e:
        logger.error(f"‚ùå Chyba p≈ôi zpracov√°n√≠ projektu {project_id}: {str(e)}", exc_info=True)
        
        if project_id in project_store:
            project_store[project_id].update({
                "status": ProjectStatus.FAILED,
                "error": str(e)
            })
    
    finally:
        # –û—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–∞–º—è—Ç—å
        gc.collect()


# =============================================================================
# MAIN ENDPOINTS
# =============================================================================

@router.get("/")
@router.get("/api/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "ok",
        "service": "Czech Building Audit System",
        "version": "1.0.0",
        "timestamp": datetime.utcnow().isoformat(),
        "limits": {
            "max_file_size_mb": MAX_FILE_SIZE / 1024 / 1024,
            "supported_formats": {
                "vykaz": list(ALLOWED_EXTENSIONS['vykaz']),
                "vykresy": list(ALLOWED_EXTENSIONS['vykresy']),
                "dokumentace": list(ALLOWED_EXTENSIONS['dokumentace'])
            }
        }
    }


@router.post("/api/upload", response_model=ProjectResponse)
async def upload_project(
    background_tasks: BackgroundTasks,
    
    # Z√ÅKLADN√ç PARAMETRY
    project_name: str = Form(..., description="N√°zev projektu"),
    workflow: str = Form(..., description="Typ workflow: 'A' nebo 'B'"),
    
    # HLAVN√ç SOUBORY
    vykaz_vymer: Optional[UploadFile] = File(
        None, 
        description="V√Ωkaz v√Ωmƒõr (povinn√© pro Workflow A)"
    ),
    
    vykresy: List[UploadFile] = File(
        default=[],
        description="V√Ωkresy (povinn√© pro oba workflows)"
    ),
    
    # VOLITELN√â SOUBORY
    rozpocet: Optional[UploadFile] = File(
        None,
        description="Rozpoƒçet s cenami (voliteln√©)"
    ),
    
    dokumentace: List[UploadFile] = File(
        default=[],
        description="Projektov√° dokumentace (voliteln√©)"
    ),
    
    zmeny: List[UploadFile] = File(
        default=[],
        description="Zmƒõny a dodatky (voliteln√©)"
    ),
    
    # MO≈ΩNOSTI
    generate_summary: bool = Form(default=True, description="Generovat summary"),
    auto_start_audit: bool = Form(default=True, description="Automaticky spustit audit")
    
) -> ProjectResponse:
    """
    Nahr√°n√≠ projektu pro audit
    
    **Workflow A (M√°m v√Ωkaz v√Ωmƒõr):**
    - ‚úÖ vykaz_vymer (POVINN√â) - pozice a mno≈æstv√≠
    - ‚úÖ vykresy (POVINN√â) - materi√°ly, podm√≠nky, kontext
    - üìÑ rozpocet, dokumentace, zmeny (voliteln√©)
    
    **Workflow B (Vytvo≈ôit z v√Ωkres≈Ø):**
    - ‚úÖ vykresy (POVINN√â) - generov√°n√≠ v√Ωkazu z v√Ωkres≈Ø
    - üìÑ dokumentace, zmeny (voliteln√©)
    
    **Limity:**
    - Maxim√°ln√≠ velikost souboru: 50 MB
    - Podporovan√© form√°ty viz /api/health
    """
    try:
        # VALIDACE workflow
        workflow = workflow.upper()
        if workflow not in ["A", "B"]:
            raise HTTPException(
                status_code=400,
                detail="Workflow mus√≠ b√Ωt 'A' nebo 'B'"
            )
        
        # VALIDACE povinn√Ωch soubor≈Ø
        if workflow == "A":
            if not vykaz_vymer:
                raise HTTPException(
                    status_code=400,
                    detail="Pro Workflow A je v√Ωkaz v√Ωmƒõr povinn√Ω"
                )
            if not vykresy or len(vykresy) == 0:
                raise HTTPException(
                    status_code=400,
                    detail="Pro Workflow A jsou v√Ωkresy povinn√© (pro kontext materi√°l≈Ø a podm√≠nek)"
                )
        
        elif workflow == "B":
            if not vykresy or len(vykresy) == 0:
                raise HTTPException(
                    status_code=400,
                    detail="Pro Workflow B jsou v√Ωkresy povinn√©"
                )
        
        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è project ID
        project_id = f"proj_{uuid.uuid4().hex[:12]}"
        
        logger.info(f"üì§ Nov√© nahr√°n√≠: {project_id} - {project_name} (Workflow {workflow})")
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π
        project_dir = settings.DATA_DIR / "raw" / project_id
        project_dir.mkdir(parents=True, exist_ok=True)
        
        # ULO≈ΩEN√ç SOUBOR≈Æ
        saved_files = {
            "vykaz_vymer": None,
            "vykresy": [],
            "rozpocet": None,
            "dokumentace": [],
            "zmeny": []
        }
        
        # 1. V√Ωkaz v√Ωmƒõr
        if vykaz_vymer:
            await _validate_file(vykaz_vymer, 'vykaz')
            
            vykaz_dir = project_dir / "vykaz_vymer"
            vykaz_dir.mkdir(exist_ok=True)
            
            vykaz_path = vykaz_dir / vykaz_vymer.filename
            size = await _save_file_streaming(vykaz_vymer, vykaz_path)
            
            saved_files["vykaz_vymer"] = {
                "path": str(vykaz_path),
                "filename": vykaz_vymer.filename,
                "size": size
            }
        
        # 2. V√Ωkresy (m≈Ø≈æe –±—ã—Ç—å –º–Ω–æ–≥–æ)
        if vykresy:
            vykresy_dir = project_dir / "vykresy"
            vykresy_dir.mkdir(exist_ok=True)
            
            for vykres in vykresy:
                await _validate_file(vykres, 'vykresy')
                
                vykres_path = vykresy_dir / vykres.filename
                size = await _save_file_streaming(vykres, vykres_path)
                
                saved_files["vykresy"].append({
                    "path": str(vykres_path),
                    "filename": vykres.filename,
                    "size": size
                })
        
        # 3. Rozpoƒçet
        if rozpocet:
            await _validate_file(rozpocet, 'vykaz')
            
            rozpocet_dir = project_dir / "rozpocet"
            rozpocet_dir.mkdir(exist_ok=True)
            
            rozpocet_path = rozpocet_dir / rozpocet.filename
            size = await _save_file_streaming(rozpocet, rozpocet_path)
            
            saved_files["rozpocet"] = {
                "path": str(rozpocet_path),
                "filename": rozpocet.filename,
                "size": size
            }
        
        # 4. Dokumentace
        if dokumentace:
            dok_dir = project_dir / "dokumentace"
            dok_dir.mkdir(exist_ok=True)
            
            for dok in dokumentace:
                await _validate_file(dok, 'dokumentace')
                
                dok_path = dok_dir / dok.filename
                size = await _save_file_streaming(dok, dok_path)
                
                saved_files["dokumentace"].append({
                    "path": str(dok_path),
                    "filename": dok.filename,
                    "size": size
                })
        
        # 5. Zmƒõny
        if zmeny:
            zmeny_dir = project_dir / "zmeny"
            zmeny_dir.mkdir(exist_ok=True)
            
            for zmena in zmeny:
                await _validate_file(zmena, 'dokumentace')
                
                zmena_path = zmeny_dir / zmena.filename
                size = await _save_file_streaming(zmena, zmena_path)
                
                saved_files["zmeny"].append({
                    "path": str(zmena_path),
                    "filename": zmena.filename,
                    "size": size
                })
        
        # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å project info
        project_info = {
            "project_id": project_id,
            "project_name": project_name,
            "workflow": workflow,
            "uploaded_at": datetime.now().isoformat(),
            "status": ProjectStatus.UPLOADED,
            "files": saved_files,
            "options": {
                "generate_summary": generate_summary,
                "auto_start_audit": auto_start_audit
            }
        }
        
        info_path = project_dir / "project_info.json"
        async with aiofiles.open(info_path, 'w', encoding='utf-8') as f:
            await f.write(json.dumps(project_info, ensure_ascii=False, indent=2))
        
        # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ store
        project_store[project_id] = project_info.copy()
        
        # –ó–∞–ø—É—Å—Ç–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É –≤ —Ñ–æ–Ω–µ
        if auto_start_audit:
            vykaz_path = Path(saved_files["vykaz_vymer"]["path"]) if saved_files["vykaz_vymer"] else None
            vykresy_paths = [Path(v["path"]) for v in saved_files["vykresy"]]
            
            background_tasks.add_task(
                _process_project_background,
                project_id=project_id,
                workflow=workflow,
                vykaz_path=vykaz_path,
                vykresy_paths=vykresy_paths,
                project_name=project_name
            )
            
            status = ProjectStatus.PROCESSING
            message = "Projekt nahr√°n a zpracov√°n√≠ zah√°jeno"
        else:
            status = ProjectStatus.UPLOADED
            message = "Projekt nahr√°n √∫spƒõ≈°nƒõ"
        
        logger.info(f"‚úÖ Nahr√°n√≠ dokonƒçeno: {project_id}")
        
        # Convert workflow string to WorkflowType enum
        workflow_type = WorkflowType.A if workflow == "A" else WorkflowType.B
        
        # Format files list for response
        files_list = []
        if saved_files["vykaz_vymer"]:
            files_list.append(saved_files["vykaz_vymer"])
        files_list.extend(saved_files["vykresy"])
        if saved_files["rozpocet"]:
            files_list.append(saved_files["rozpocet"])
        files_list.extend(saved_files["dokumentace"])
        files_list.extend(saved_files["zmeny"])
        
        return ProjectResponse(
            project_id=project_id,
            name=project_name,
            status=status,
            upload_timestamp=datetime.now(),
            workflow=workflow_type,
            files=files_list,
            message=message
        )
        
    except ValueError as e:
        logger.error(f"Chyba validace: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))
    
    except Exception as e:
        logger.error(f"Chyba p≈ôi nahr√°v√°n√≠: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Chyba serveru: {str(e)}")


@router.get("/api/projects/{project_id}/status", response_model=ProjectStatusResponse)
async def get_project_status(project_id: str) -> ProjectStatusResponse:
    """
    Z√≠skat stav projektu
    
    Args:
        project_id: ID projektu
    
    Returns:
        Aktu√°ln√≠ stav zpracov√°n√≠
    """
    if project_id not in project_store:
        raise HTTPException(status_code=404, detail="Projekt nenalezen")
    
    project = project_store[project_id]
    status = project.get("status", ProjectStatus.UPLOADED)
    
    # Vypoƒç√≠tat progress
    progress_map = {
        ProjectStatus.UPLOADED: 10,
        ProjectStatus.PROCESSING: 50,
        ProjectStatus.COMPLETED: 100,
        ProjectStatus.FAILED: 0,
    }
    progress = progress_map.get(status, 0)
    
    # Zpr√°va podle stavu
    messages = {
        ProjectStatus.UPLOADED: "Projekt nahr√°n, ƒçek√° na zpracov√°n√≠",
        ProjectStatus.PROCESSING: "Prob√≠h√° zpracov√°n√≠...",
        ProjectStatus.COMPLETED: "Zpracov√°n√≠ dokonƒçeno",
        ProjectStatus.FAILED: f"Chyba: {project.get('error', 'Nezn√°m√° chyba')}",
    }
    
    return ProjectStatusResponse(
        project_id=project_id,
        status=status,
        progress=progress,
        message=messages.get(status, "Nezn√°m√Ω stav"),
        positions_total=project.get("total_positions", 0),
        positions_processed=project.get("total_positions", 0) if status == ProjectStatus.COMPLETED else 0,
        green_count=project.get("green_count", 0),
        amber_count=project.get("amber_count", 0),
        red_count=project.get("red_count", 0)
    )


@router.get("/api/projects/{project_id}/results")
async def get_project_results(project_id: str):
    """
    Z√≠skat v√Ωsledky auditu
    
    Args:
        project_id: ID projektu
    
    Returns:
        Excel soubor s v√Ωsledky nebo JSON
    """
    if project_id not in project_store:
        raise HTTPException(status_code=404, detail="Projekt nenalezen")
    
    project = project_store[project_id]
    
    if project.get("status") != ProjectStatus.COMPLETED:
        raise HTTPException(
            status_code=400,
            detail=f"Projekt je≈°tƒõ nen√≠ dokonƒçen. Aktu√°ln√≠ stav: {project.get('status')}"
        )
    
    results_path = project.get("results_path")
    if not results_path or not Path(results_path).exists():
        raise HTTPException(status_code=404, detail="V√Ωsledky nenalezeny")
    
    # Vr√°tit JSON s v√Ωsledky
    async with aiofiles.open(results_path, 'r', encoding='utf-8') as f:
        content = await f.read()
        results = json.loads(content)
    
    return results


# =============================================================================
# KNOWLEDGE BASE ENDPOINTS
# =============================================================================

@router.get("/api/kb/status")
async def get_kb_status():
    """Z√≠skat stav Knowledge Base"""
    from app.core.kb_loader import get_knowledge_base
    
    kb = get_knowledge_base()
    
    categories = {}
    for category in kb.data:
        data = kb.data[category]
        metadata = kb.metadata.get(category, {})
        categories[category] = {
            "files": len(data) if isinstance(data, dict) else 1,
            "version": metadata.get("version", "1.0"),
            "loaded_at": metadata.get("loaded_at", "unknown")
        }
    
    return {
        "status": "loaded",
        "total_categories": len(categories),
        "categories": categories
    }


@router.post("/api/kb/reload")
async def reload_kb():
    """Znovu naƒç√≠st Knowledge Base"""
    try:
        from app.core.kb_loader import get_knowledge_base
        from app.core import kb_loader as kb_module
        
        # Reset singleton
        kb_module._kb_instance = None
        
        # Reload KB
        kb = get_knowledge_base()
        
        return {
            "status": "reloaded",
            "message": "Knowledge Base byla √∫spƒõ≈°nƒõ znovu naƒçtena",
            "categories": len(kb.data)
        }
    except Exception as e:
        logger.error(f"Chyba p≈ôi naƒç√≠t√°n√≠ KB: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
